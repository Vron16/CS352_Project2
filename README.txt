1. Please write down the full names and netids of all your team members.
Asmaa Hasan (aah150)
Varun Ravichandran (vr250)
2. Briefly discuss how you implemented the LS functionality of tracking which TS responded to the
query and timing out if neither TS responded.
The LS first creates a socket by binding to the user-specified port on the hostname of the machine it is running on. It accepts up to 10 connections at a time, which means that up to 10 clients can be serviced at once due to multithreading. When an incoming connection comes from a client (on any machine), it accepts the connection and calls the handle_connection function in a new thread in order to provide the necessary services for that client. First, it creates two additional sockets: one for each top-level server with which it has to communicate. Then, it performs a blocking recv call on the client socket, which will let it wait as long as necessary to receive the first hostname-query from the client. Once it gets that data, it forwards that queried hostname it just received to both of the top-level servers. Rather than performing the typical blocking recv call, it uses select to provide a non-blocking, parallelized protocol to wait for a response. The input to the select call is an array containing both of the sockets that communicate with ts_1 and ts_2, respectively. The select call is also parameterized by a timeout value of 5 seconds. As a result, select returns as soon as any of the sockets in the input array become ready for reading or simply after a 5 second-delay, whichever occurs first. After select returns, the LS checks if the length of the array returned is 1 or 0. Note: I assume that a given hostname can only be present in at most 1 of the TS's tables, so I raise an error if multiple sockets responded to a query. If the length of the output array is 0, then neither of the sockets had sent back any data, and select had returned due to a timeout. Therefore, the LS promptly sends the Error:HOST NOT FOUND message in that event. If the length of the output array is 1, the LS checks if the first socket in the returned array of "ready sockets" corresponds to the socket used to communicate with ts_1 or ts_2. It accordingly calls recv on the corresponding socket and forwards the message from the TS back to the client. Since we called select and received a non-empty array of sockets in return, we can rest assured when we call recv() on that socket that the call will not block. In this manner, the LS communicates with both of the TS's in parallel and returns the IP address that maps to the queried hostname, regardless of which TS it was stored in. Finally, it sends the message back to the client via the socket it was using to communicate with the client. The thread remains active in a loop until it receives the string 'done' from the client. At that stage, the function breaks out of its loop, closes all of its sockets, and shuts down the thread. Meanwhile, the original LS server thread continues listening for new client connections to handle.
3. Are there known issues or functions that aren't working currently in your attached code? If so,
explain
As of now, there are no known issues in our code. We have not tested the code with multiple clients querying the load-balancing server simultaneously, although it should be designed to handle this since it is multithreaded. However, that was not an expectation for this project, so that is not really an issue in the code at all. We used the select UNIX call to communicate with both TS servers essentially simultaneously, so responses should appear based on the speed of the network for queries that are in either TS table and a little over 5 seconds (accounting for network delay) for hostname queries that are not in either table. We have tested to make sure that performance is not impacted based on the machines that the servers and client is ran on, and have ensured that the servers can locate hostname queries on a case-insensitive basis. 
4. What problems did you face developing code for this project?
The biggest challenge was determining how to make the LS communicate with both of the TS servers in a parallel, non-blocking manner despite recv()'s inherently blocking nature. Therefore, it took some time to get used to the semantics of select and then applying it such that we could guarantee that any calls to recv() would result in a response within 5 seconds. Initially, it seemed as though we would only be able to query each of the TS servers sequentially from the LS, which seemed less robust than a parallelized implementation that automatically read from the socket that returned first, if possible. Fortunately, the hint about select provided was enough to eventually get us to a parallelized solution. The client was quite straightforward to develop since it was largely derivative from the previous project and first HW to read from the file, create a connection to the LS, send hostnames to the server, and write responses to the output file.
5. What did you learn by working on the project?
The previous project taught us the basics of file and socket I/O with Python. This project expanded on that and also taught us how to use select in order to ensure that we can communicate with multiple servers in parallel without necessarily using multithreading. Effectively, we now know how to communicate with multiple machines at once and act based on the status of other machines (when they are listening for data to be written to them or when they have just sent data that we can read).